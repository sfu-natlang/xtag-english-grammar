\chapter{Metarules}
\label{metarules}

\section{Introduction}
\label{introduction}

The system of metarules is a collection of functions accessible from the XTAG
user interface that help the user in the construction and maintenance of a tag
tree-grammar.  Here our primary purpose is to describe the facilities that
exist for using metarules.  For a discussion of metarules as a method for
compact representation of the Lexicon see \cite{becker93} and \cite{srini94}.

The basic idea of using metarules is to take advantage of the similarities of
the relations involving related pairs of XTAG elementary trees.  For example,
in the English grammar described in this technical report, comparing the XTAG
trees for the basic form and the wh-subject moved form, the relation between
this two trees for transitive verbs ($\alpha nx_0Vnx_1$, $\alpha W_0nx_0Vnx_1$)
is similar to the relation for the intransitive verbs ($\alpha nx_0V$, $\alpha
W_0nx_0V$) and also to the relation for the ditransitives ($\alpha
nx_0Vnx_1nx_2$, $\alpha W_0nx_0Vnx_1nx_2$). Hence, instead of generating by
hand the six trees mentioned above, a more natural and robust way would be
generating by hand only the basic trees for the intransitive, transitive and
ditransitive cases, and letting the wh-subject moved trees to be automatically
generated by the application of a unique transformation rule that would account
exactly for the identical relation involved in each of the three pairs above.

Notice that the degree of generalization can be much higher than it might be
thought in principle from the above paragraph. For example, once a rule for
passivization is applied to the three different basic trees above, the 
wh-subject moved rule could be again applied to generate the wh-moved subject
versions for the passive form. It is important to note that such recursive
applications of metarules still always result in a finite number of trees in
the grammar.


We still make here a point that the reduction of effort in grammar construction
is not the only advantage of the approach. Robustness, 
reliability and maintainability of the grammar achieved by the use of  
metarules are equally or even more important.

In the next section we define a metarule in XTAG. 
Section \ref{examples} gives some
linguistically motivated examples
of metarules for the English grammar described in this
technical report and their application. Section \ref{access} 
describes the access through 
the user interface.
%Section 3 describes the access through the user interface.

\section{The definition of a metarule in XTAG}
\label{definition}

A metarule specifies a rule for transforming grammar rules into grammar rules. 
In XTAG the grammar 
rules are lexicalized trees. Hence an XTAG metarule {\bf mr} 
is a pair {\bf (lhs, rhs)} of XTAG trees, where:

\begin{itemize}
\item {\bf lhs}, the {\it left-hand side} of the metarule, is a pattern tree,
        i.e., it is intended to present a specific pattern of tree to look for
        in the trees submitted to the application of the metarule.

\item When a metarule {\bf mr} is applied to an input tree {\bf inp}, the first
        step is to verify if the input tree matches the pattern specified by
        the {\bf lhs}. If there is no match, the application {\it fails}.

\item {\bf rhs}, the {\it right-hand side} of the metarule, specifies (together
        with {\bf lhs}) the transformation that will be done in {\bf inp},
        in case of successful matching, thus generating the output tree of
        the metarule application\footnote{Actually more than one output tree 
        can be generated from the successful application of a rule to an 
        input tree, as will be seen later in this chapter}.
\end{itemize}
 
\subsection{Node names, variable instantiation, and matches}

We will use the terms {\bf lhs}, {\bf rhs} and {\bf inp} as introduced above
to refer to the parts of a generic metarule being applied to an input tree. 

The nodes at {\bf lhs} can take three 
different forms: a constant node, a typed variable node, and a non-typed 
variable node. The naming conventions for these different classes of nodes is 
given below.

\begin{itemize}

\item {\bf Constant Node:} Its name must not begin with a question mark
        (`?' character). They follow the same conventions used in normal
        XTAG trees; for instance, {\bf inp} is expected to have only constant
        nodes. Some examples of constant nodes are $NP$, $V$, $NP_0$, $NP_1$,
        $S_r$. We will call the two parts that compose such names
        the {\it stem} and the {\it subscript}.
        In the examples above  $NP$, $V$ and $S$ are stems and 
        $0$, $1$, $r$ are subscripts. Notice that the
        subscript part can also be empty.

\item {\bf Non-Typed Variable Node:} Its name begins with a question 
        mark (`?'), followed by a sequence of digits (i.e., a number) which
        uniquely identifies the variable. Examples: ?1, ?3,
        ?3452.\footnote{Notice however that having the sole purpose of
        distinguishing between variables, a number like the one in the last
        example is not very likely to occur, and a metarule with more than
        three thousand variables can give you a place in the Guinness TagBook
        of Records.} There is no stem and no subscript in these
        names, i.e., `?' is just a meta-character to introduce a variable, and
        the number is the variable identifier.

\item {\bf Typed Variable Node:} Its name begins with a question mark (`?')
        followed by a sequence of digits, but is additionally followed by a
        {\it type specifiers definition}. A {\it type specifiers definition} is
        a sequence of one or more {\it type specifier} separated by a slash
        (`/'). A {\it type specifier} has the same form of a regular XTAG node
        name (like the constant nodes), except that the subscript can be also a
        question mark. Examples of typed variables are: $?1VP$ (a single type
        specifier with stem $VP$ and no subscript), $?3NP_1/PP$ (two type
        specifiers, $NP_1$ and $PP$), $?1NP_?$ (one type specifier, $NP_?$ with
        undetermined subscript).  Each type specifier represents an alternative
        for matching, and the presence of `?' in subscript position of a type
        specifier means that matching will only check for the stem
        \footnote{This is different from not having a subscript, which is
       	interpreted as checking that the matching node at the input tree
        has no subscript}.
\end{itemize}

During the process of matching, variables are associated (we use the
term {\it instantiated}) with `tree material'.  According to its class
a variable may be instantiated with different kinds of tree material:

\begin{itemize}
\item   A typed variable will be instantiated with exactly one node of
        the input tree, which is in accordance to one of its type specifiers
        (The full rule is in the following subsection). 

\item   A non-typed variable will be instantiated by a sequence of subtrees.
        These subtrees will be taken from one of the nodes of the input tree
        {\bf inp}. Hence, there will be a node $n$ in {\bf inp}, with subtrees
        $n.t_1$, $n.t_2$, ..., $n.t_k$, in this order, where the variable
        will be instantiated with some subsequence of these subtrees 
        (e.g., $n.t_2$, $n.t_3$, $n.t_4$). Note however, that some of these
        subtrees, may be incomplete, i.e., they may not go all the way to the 
        bottom leaves. Entire subtrees may be removed. Actually for each
        child of the non-typed variable node, one subtree that matches this
        child subtree will be removed from some of the $n.t_i$(maybe an entire
        $n.t_i$), leaving in place a mark for inserting material during the
        substitution of occurrences at {\bf rhs}.\\
        Notice still that the variable may
        be instantiated with a single tree and even with no tree. 

\end{itemize} 

We define a {\it match} to be a complete instantiation of all variables 
appearing in the metarule. In the process of matching, there may be several
possible ways of instantiating the set of variables of the metarule, i.e.,
several possible matches. This is due to the presence of non-typed variables.

Now, we are ready to define what we mean by a successful matching. The process
of matching is {\it successful} 
if the number of possible matches is greater then 0.
When there is no possible match the process is said to {\it fail}.
In addition to returning success or failure, the 
matching process also returns the set of
all possible {\it matches}, which will be used for generating the output.

\subsection{Structural Matching}

The process of matching {\bf lhs} with {\bf inp} can be seen as a recursive 
procedure for matching trees, starting at their roots and proceeding in a 
top-down style along with their subtrees. 
In the explanation of this process that 
follows we use the term {\bf lhs} not only to refer to the whole tree 
that contains the pattern 
but to any of its subtrees that is being considered in a 
given recursive step. The same applies to {\bf inp}. 
By now we ignore feature equations,
which will be accounted for in the next subsection.

The process described below returns at the end the set of matches (where an
empty set means failure). We first give one auxiliary definition, of valid
Mapping, and one recursive function Match, that matches lists of trees instead
of trees, and then define the process of matching two trees as a special case
of call to Match.

Given a list $list_{lhs}=[lhs_1, lhs_2, ..., lhs_l]$ of nodes of {\bf lhs}
and a list $list_{inp}=[inp_1, inp_2, ..., inp_i]$ of nodes of {\bf inp},
we define a {\it mapping} from $list_{lhs}$ to $list_{inp}$ to be a function
$Mapping$,
that for each element of $list_{lhs}$ assigns a list of elements of 
$list_{inp}$, defined by the following condition:
$$concatenation\ (Mapping(lhs_1),\ Mapping(lhs_2),\ ...,\ Mapping(lhs_l))\ =\ 
        list_{inp}$$
That is, the elements of $list_{inp}$ are split into sublists and assigned in 
order of appearance in the list to the elements of $list_{lhs}$.

We say that a mapping is a {\it valid mapping} if for all $j$, $1\leq j \leq l$
(where $l$ is the length of $list_{lhs}$), the following restrictions apply:

\begin{enumerate}

\item if $lhs_j$ is a constant node, then $Mapping(lhs_j)$ must have a 
        single element, say, $inp_{g(j)}$, and the two nodes must have the same
        name and agree on the markers (foot, substitution, head and NA), i.e.,
        if $lhs_j$ is NA, then $inp_{g(j)}$ must be NA, 
        if $lhs_j$ has no markers, then $inp_{g(j)}$ must have no markers, etc.

\item if $lhs_j$ is a typed variable node, then $Mapping(lhs_j)$ must have a 
        single element, say, $inp_{g(j)}$, and $inp_{g(j)}$ must be 
        {\it marker-compatible} and 
        {\it type-compatible} with $lhs_j$. \\
        $inp_{g(j)}$ is 
        {\it marker-compatible} with $lhs_j$ if any marker
         (foot, substitution, head and NA) present in $lhs_j$ is also
        present in $inp_{g(j)}$\footnote{Notice that, unlike the case for the
        constant node, the inverse is not required, 
        i.e., if $lhs_j$ has no marker, $inp_{g(j)}$ is still 
        allowed to have one.}.\\
        $inp_{g(j)}$ is {\it type-compatible} with $lhs_j$ 
        if at least one of the alternative 
        type specifiers for the typed variable $lhs_j$ satisfies 
        the conditions below:

\begin{itemize}
\item   $inp_{g(j)}$ has the stem defined in the type specifier.
\item   if the type specifier doesn't have a subscript, then 
        $inp_{g(j)}$ must have no subscript.
\item   if the type specifier has a subscript different from `?', then 
        $inp_{g(j)}$ must have the same subscript as in the type specifier
        \footnote{If the type specifier has a `?' subscript, there is no
        restriction, and that is exactly its function: to allow for the 
        matching to be independent of the subscript.}.
\end{itemize}

\item if $lhs_j$ is a non-typed variable node, then there is no
        requirement: $Mapping(lhs_j)$ may have any length and even be 
        empty.
\end{enumerate}
        
The following algorithm, Match, takes as input a list of nodes of {\bf lhs}
and a list of nodes of {\bf inp}, and returns the set of possible matches
generated in the attempt of match this two lists. If the result is an empty
set, this means that the matching failed.

\begin{figure}[p]
%\centering
\begin{tabular}{l}
\psfig{figure=ps/metarulealgo.eps,height=7.9in}
\end{tabular}
\caption{Metarule matching algorithm}
\label{metarule-algo}
\end{figure}

Finally we can define the process of structurally matching {\bf lhs} to
{\bf inp} as the evaluation of Match([root({\bf lhs})], [root({\bf inp})].
If the result is an empty set, the matching failed, otherwise the resulting
set is the set of possible matches that will be used for generating the
new trees (after being pruned by the feature equation matching).

\subsection{Output Generation}
\label{output-gen}

Although nothing has yet been said about the feature
equations (see the next subsection), we assume that only
matches that meet the additional constraints imposed by feature equations
are considered for output. If no structural match survives feature equations
checking, that matching has failed.

If the process of matching {\bf lhs} to {\bf inp} fails, there are two 
alternative behaviors according to the value of a parameter\footnote{The
parameter is accessible from the Lisp interface by the name 
{\it XTAG::*metarules-copy-unmatched-trees*}.
At the end of section \ref{access} it is shown how to change the value
of this parameter through the XTAG interface.}. 
If the parameter is set to ``false'', which is the {\it default} value, 
no output is generated. 
On the other hand, if 
it is set to ``true'', then the own {\bf inp} tree is copied to the 
output\footnote{As will be seen in section \ref{access} the cumulative
mode of application is not affected by this parameter.}.

If the process of matching succeeds, as many trees will be generated in the
output as the number of possible matches obtained in the process. For a 
given match, the output tree is generated by substituting the occurrences of variables in the {\bf rhs} tree
of the metarule by the material to which they have
been instantiated in the match. In the case of typed-variables,
the name of the variable is just substituted by the name of the node to which
it has been instantiated from {\bf inp}. An important detail is how the
markers (foot, substitution, head, NA) are set in the output tree 
node. The rule is that, if the occurrence of the variable at the {\bf rhs}
tree has any marker, then the generated node will inherit ALL 
markers from the {\bf rhs} node. If it has no marker, then all the markers 
at the generated node will come from {\bf inp}. The exception to the rule is 
that if the generated node has any children, then it will not be marked
substitution, foot, or anchor, despite what the previous rule say.

The case of non-typed variables, not surpringly, is not so simple.  In the
output tree, this node will be substituted by the subtree list that was
associated to this variable, in the same order, attaching to the parent of this
non-typed variable node.  But remember that some subtrees may have been removed
from some of the trees in this list (maybe entire elements of this list) due to
the effect of the children of the metavariable in {\bf lhs}.  It is a
requirement that any occurence of a non-typed variable node at the {\bf rhs}
tree has exactly the same number of children as the unique occurence of this
non-typed variable node in {\bf lhs}. Hence, when generating the output tree,
the subtrees at {\bf rhs} will be inserted exactly at the points where subtrees
were removed during matching, in a positional, one to one correspondance. If
one wants any of these cutting points to be left empty, as if the subtree has
been removed at the substitution points, the corresponding children at the {\bf
rhs} tree have to be labeled {\bf EMPTY}.

\subsection{Feature Matching}

In the previous subsections we have considered only the aspects of a metarule
involving the structural part of the XTAG trees. In a feature based grammar
such as XTAG, accounting for features is essential. A metarule must account for
the proper change of feature equations\footnote{Notice that what is really
important is not the features themselves, but the feature equations that relate
the feature values of nodes of the same tree.} from the input to the output
tree.  The aspects that have to be considered here are:

\begin{itemize}
\item   Which feature equations should be required to be present in {\bf inp}
        in order for the match to succeed.

\item   Which feature equations should be generated in the output tree as a 
        function of the feature equations in the input tree.
\end{itemize}

Based on the combinations of these aspects the user may specify for a feature
equation to be considered in the following ways:

\begin{itemize}
\item   {\it Require \& Retain:} The feature equation
        is required to be in {\bf inp} in order for matching to succeed.
        Upon matching, the equation will be copied to the output tree.
        To achieve this behaviour, the equation must be placed in 
        the {\bf lhs} tree of the metarule preceded by a plus character
        (e.g. $+V.t:<trans>=+$).\footnote{Commutativity of equations is 
        accounted for in the system. Hence an equation $x=y$ can also be
        specified as $y=x$. Associativity is not accounted for and its need by
        an user is viewed as indicating misspecification at the input trees.}
        
\item   {\it Require \& Don't Copy:} The equation is required to be in 
        {\bf inp}
        for matching, but should not be copied to the output tree.
        To have this behavior, the equation must be in {\bf lhs} preceded 
	by the minus character
        (e.g. $-NP_1:<case>=acc$).

\item	{\it Negative Requirement:} In order for matching to succeed the 
	equation should not be found in {\bf inp}. This is achieved by
	including the equation in {\bf lhs} preceded by a caret
	(e.g., $\verb|^|V.b:<passive>=-$).

\item   {\it Optional \& Don't Copy:} 
        The equation is not required for matching,
        but we have to make sure not to copy it to the output tree set of
        equations, regardless of it being present or not in {\bf inp}.
        Those equations must be in {\bf lhs} in raw form, i.e., neither preceded
        by a plus nor minus character
        (e.g. $S_r.b:<perfect>=VP.t:<perfect>$).

\item   {\it Optional \& Retain:} 
        The equation is not required for matching, but
        in case it is found in {\bf inp} it must be copied to the output tree.
        This is the {\it default} case, and hence these equations should not be
        present in the metarule specification.

\item   {\it Add:} The equation is not required for matching but we want it to
        be put in the output tree anyway.
        These equations are placed in raw form in the {\bf rhs} (notice in this
        case it is the right hand side tree).
\end{itemize}

There are also some directives available to handle feature equations. For 
convenience and conformance with the pre-existing interface functions,
these directives were defined to be included in the {\bf lhs} tree as feature 
equations among the equations for requirement/copy defined above. The
equations/directives will be interpreted and executed 
in the order they appear in the feature equations list definition 
of the {\bf lhs} tree. The general format of a directive is:

\centerline{D{\it{}name1} $:\ <$ {\it{}dummy1} $>\ =$ {\it{}name2}}

where ``D'' is a single character that specifies the directive, 
as listed below;
{\it name1} and {\it name2} are parameters of the directive; 
and {\it dummy1} (which may literally be the word ``dummy'') is required only
to conform to the pre-existing format for feature equations in XTAG.
There must be no blank space between the directive symbol and {\it name1}.
The currently implemented directives are:

\begin{itemize}
\item[$\backslash :$] replace {\it name1} with {\it name2} in all 
	equations from
	the input tree.
\item[{$|:$}] exchange {\it name1} and {\it name2} in all equations from
	the input tree.
\item[{$!:$}] remove all equations where {\it name1} appears 
	(here, {\it name2} is also dummy).
\end{itemize}

Notice that the equations are executed in order. Hence, for instance, if there
is a directive to remove equation E before an equation that requires E to
be present for matching, matching will always fail. Similarly replacing and
exchanging feature names will affect and be affected by the behavior of
surrounding equations. 

In the rest of this subsection we define the role of the meta-variables 
in the feature equations. Importantly, we will overload the notation used up
til now in this chapter and use the terms ``left'' and ``right hand
side'' ({\bf lhs} and {\bf rhs} for short) to refer to the sides of a
feature equation from a tree, and not only to the sides of the metarule.

Non-typed variables don't play any role in the manipulation of feature
equations by the metarules.
Typed variables can be used in feature equations in both {\bf lhs} and 
{\bf rhs} side of the equation. 
They are intended to represent the nodes of the input tree with which
the variables have been instantiated. For each resulting match 
from the structural matching process the following is done:

\begin{itemize}
\item   The (typed) variables in the equations at {\bf lhs} and {\bf rhs} are 
        substituted by the names of the nodes they have been instantiated to.

\item   The requirements concerning feature equations are checked, according
        to the above rules.

\item   If the match survives feature equation checking, the proper output tree
        is generated, according to Section~\ref{output-gen} and to the 
        rules described above for the feature equations.
\end{itemize}

Finally, a new kind of metavariable, which is not used at the nodes, can be
introduced in the feature equations part. It has the same form of the
non-typed variables, i.e., a question mark followed by a number, and is used
in place of feature values and feature names. Hence, if the equation
$NP_r.b:<?2> = ?3$ appears in {\bf lhs}, then all feature
equations of {\bf inp} that equate a certain  bottom attribute(?2) of node 
$NP_r$ to a certain feature value (?3) (but not to a feature path) will not 
be copied to the output. Notice that before the first time the variables ?2 
and ?3 match an equation from {\bf inp}, they are free and can match 
any feature
value/name. But after a match occurs, 
they become bound to the matched values, and
henceforth they will only match these values. 

\setcounter{topnumber}{4}
\setcounter{bottomnumber}{4}
\setcounter{totalnumber}{4}
%\section{Examples of the Application of Metarules}

\section{Examples}
\label{examples}

Figure~\ref{wh-subj} shows a metarule for wh-movement of the subject. Among
the trees to which it have been applied are the basic trees of intransitive, 
transitive and ditransitive families (including prepositional complements),
passive trees of the same families, and ergative.

\begin{figure}[htb]
\begin{center}
\begin{tabular}{c@{\hspace{2em}}c}
\framebox{\psfig{figure=fig/lhs-wh-subj.ps,height=2.0in}} &
\framebox{\psfig{figure=fig/rhs-wh-subj.ps,height=2.5in}} \\
{lhs} & {rhs} \\
\end{tabular}
\end{center}
\caption{Metarule for wh-movement of subject}
\label{wh-subj}
\end{figure}

Figure~\ref{wh-obj} shows a metarule for wh-movement of an NP in object
position. Among
the trees to which it have been applied are the basic and passive trees of  
transitive and ditransitive families.

\begin{figure}[!htb]
\begin{center}
\begin{tabular}{c@{\hspace{2em}}c}
\framebox{\psfig{figure=fig/lhs-wh-obj.ps,height=2.9in}} &
\framebox{\psfig{figure=fig/rhs-wh-obj.ps,height=2.9in}} \\
{lhs} & {rhs} \\
\end{tabular}
\end{center}
\caption{Metarule for wh-movement of object}
\label{wh-obj}
\end{figure}

Figure~\ref{wh} shows a metarule for general wh-movement of an NP.  It can be
applied to generate trees with either subject or object NP
moved. Figure~\ref{prep} shows the basic tree for the family Tnx0Vnx1Pnx2 and
the three wh-trees generated by the application of the rule.

\begin{figure}[!htb]
\begin{center}
\begin{tabular}{c@{\hspace{2em}}c}
\framebox{\psfig{figure=fig/lhs-wh.ps,height=2.5in}} &
\framebox{\psfig{figure=fig/rhs-wh.ps,height=2.5in}} \\
{lhs} & {rhs} \\
\end{tabular}
\end{center}
\caption{Metarule for general wh movement of an NP}
\label{wh}
\end{figure}

\begin{figure}[!htb]
\begin{center}
\begin{tabular}{c@{\hspace{2em}}c}
\framebox{\psfig{figure=fig/prep.ps,height=3.0in}} &
\framebox{\psfig{figure=fig/prep1.ps,height=3.0in}} \\
{Tnx0Vnx1Pnx2} & {subject moved} \\
\\
\framebox{\psfig{figure=fig/prep2.ps,height=3.0in}} &
\framebox{\psfig{figure=fig/prep3.ps,height=3.0in}} \\
{NP object moved} & {NP object moved from PP} \\
\end{tabular}
\end{center}
\caption{Application of wh-movement rule to Tnx0Vnx1Pnx2}
\label{prep}
\end{figure}

\section{The Access to the Metarules through the XTAG Interface}
\label{access}

We first describe the access to the metarules subsystem using buffers with
single metarule applications. Then we proceed by describing the application of 
multiple metarules in what we call the parallel, sequential, and cumulative
modes to input tree files. 

We have defined a metarule conceptually as an ordered pair of trees.  In the
implementation of the metarule subsystem it works the same: a metarule is a
buffer with two trees. The name of the metarule is the name of the buffer. The
first tree that appears in the main window under the metarule buffer is the
{\it left hand side}, the next appearing below is the {\it right hand
side}\footnote{Although a buffer is intended to implement the concept of a set
(not a sequence) of trees we take advantage of the actual organization of the
system to realize the concept of (ordered) tree pair in the implementation.}.
The positional approach allows us to have naming freedom: the tree names are
irrelevant\footnote{So that even if we want to have mnemonic names resembling
their distinct character - left or right hand side, - we have some flexibility
in naming them, e.g. {\it lhs23} or {\it lhs-passive}.}.  Since we can save
buffers into text files, we can also talk about metarule files. \\

The available options for applying a metarule which is in a buffer are:

\begin{itemize}
\item   For applying a metarule to a single input tree, click on the name of
	the tree in the main window, and choose the option {\it apply metarule
        to tree}.  You will be prompted for the name of the metarule to apply
        to the tree which should be, as we mentioned before, the name of the
        buffer that contains the metarule trees. The output trees will be
        generated at the end of the buffer that contains the input tree. The
        names of the trees depend on a LISP parameter: {\it
        *metarules-change-name* }.  If the value of the parameter is {\bf
        false}, (the {\it default} value), then the new trees will have the
        same name as the input, otherwise, the name of the input tree followed
        by a dash (`-') and the name of the right hand side of the
        tree\footnote{The reason we do not use the name of the metarule, that
        is, the name of the buffer, is because in some forms of application the
        metarules do not carry individual names, which, as we will see, is the
        case when a set of metarules from a file is applied.}.

        The value of the parameter can be changed by choosing {\it Tools} 
        at the menu bar and then either {\it name mr output trees =
        input}  or {\it append rhs name to mr output trees}.

        
\item   For applying a metarule to all the trees of a buffer, click on the name
	of the buffer that contains the trees and proceed as above. The output
        will be a new buffer with all the output trees. The name of the new
        buffer will be the same as the input buffer prefixed by "MR-". The
        names of the trees follow the conventions above.

\end{itemize}

The other options concern application to files (instead of buffers). 
We will first define
the concepts of parallel, sequential and cumulative application of metarules. 
One metarule 
file can contain more than one metarule. The first two trees, i.e., the first
tree pair, form one metarule -- call it $mr_0$. Subsequent pairs in the
sequence of trees define additional metarules --- 
$mr_1$, $mr_2$, ..., $mr_n$.

\begin{itemize}
\item We say that a metarule file is applied in parallel to a tree 
(see Figure~\ref{parallel})
if each of the 
metarules is applied independently to the input generating its particular 
output trees\footnote{Remember that a metarule application generates as many 
output trees as the number of matches.}. We generalize the concept to the
application in parallel of a metarule file to a tree file (with possibly more 
than one tree), generating all the trees
as if each metarule in the metarule file was applied to each tree in the
input file.

\begin{figure}[htb]
\centerline{\psfig{figure=fig/parallel.ps,height=120pt}}
%\centerline{\psfig{figure=fig/parallel.ps,scale=60}}
%\centerline{\psfig{figure=fig/parallel.ps,width=330pt}}
\caption{Parallel application of metarules}
\label{parallel}
\end{figure}

\item We say that a metarule file $mr_0, mr_1, mr_2, ...,mr_n$ is applied in 
sequence to an input tree file 
(see Figure~\ref{sequential})
if we apply $mr_0$ to the trees of the input file, and
for each $0<i\leq n$ apply metarule $mr_i$ to the trees generated as a 
result of the application of $mr_{i-1}$.

\begin{figure}[htb]
\centerline{\psfig{figure=fig/sequential.ps,height=41pt}}
%\centerline{\psfig{figure=fig/sequential.ps,scale=60}}
\caption{Sequential application of metarules}
\label{sequential}
\end{figure}

\item Finally, the cumulative application is similar to the sequential, 
except that the input trees at each stage are passed to the output together
with the newly generated ones (see Figure~\ref{cumulative}).

\begin{figure}[htb]
\centerline{\psfig{figure=fig/cumulative.ps,height=53pt}}
%\centerline{\psfig{figure=fig/cumulative.ps,scale=60}}
\caption{Cumulative application of metarules}
\label{cumulative}
\end{figure}

\end{itemize}

Remember that in case of matching failure the output result is decided (as 
explained in subsection~\ref{output-gen}) either to be empty or to be the 
input tree. The reflex here of having the parameter set for copying the input
is that for the parallel application the output will have as many copies of
the input as matching failures. For the sequential case the decision is applied
at each level, and setting the parameter for copying, in a certain sense, 
guarantees that subsequent metarule applications will not break.
Due to its nature, and unlike the two other modes, the cumulative 
application is not affected by this parameter.

The options for application of metarules to files are available by clicking
on the menu item {\it Tools} and then choosing the appropriate function
from the following:

\begin{itemize}
\item   {\it Apply metarule to files:}  
        You will be prompted for the metarule file name which should contain
        one metarule\footnote{If the file contains more than 2 trees, the
        additional trees are ignored.}, and for input file names.  Each input
        file name {\bf inpfile} will be independently submitted to the
        application of the metarule generating an output file with the name
        {\bf MR-inpfile}.

\item   {\it Apply metarules in parallel to files:}
        You will be prompted for the metarules file name with one or more 
        metarules and for input file names.
        Each input file name {\bf inpfile} will be independently submitted to 
        the application of the metarules in parallel. For each parallel 
        application to a file {\bf inpfile} an output file with the 
        name    {\bf MRP-inpfile} will be generated.

\item   {\it Apply metarules in sequence to files:}  
        The interaction is as described for the application in parallel, 
        except that
        the application of the metarules are in sequence and that 
        the output files are prefixed by {\bf MRS-} instead of {\bf MRP-}.

\item   {\it Apply metarules cumulatively to files:}  
        The interaction is as described for the applications in parallel
        and in sequence, except that the mode of application is cumulative
        and that the output files are prefixed by {\bf MRC-}.
\end{itemize}

%For each case the user has the possibility of choosing what to do in the case
%of matching failure as discussed in the previous session.

The {\it Tools} menu also has entries to change the parameters of execution of
metarules. We saw earlier in this section how to set the parameter that
controls the name of the tree. Another parameter, explained in
Subsection~\ref{output-gen}, is the one that controls the output result on
matching failure. We can change it in the menu by selecting either {\it copy
input on mr matching failure} or {\it no output on mr matching failure}. Recall
that this parameter does not affect the cumulative mode.  The third parameter
controls comments generation. By choosing {\it append metarule comments} at
the {\it Tools} menu, the subsequent metarule applications will produce output
trees whose comments are the comments at the {\bf lhs} tree of the metarule
followed by the comments at {\bf inp}. Both parts are introduced by appropriate
headers, allowing the user to have a complete history of each tree. Choosing
{\it do not append metarule comments} makes the comments at the output trees
be exactly the same at the input tree. The third option, {\it clear comments on
metarule application}, causes the comment field to be left empty at the ouput
trees.

The default values for the tree parameters when XTAG is started are set:
to generate the output trees with the same name as the input; not to copy
the input tree in case of matching failure; and to add the metarule comments
to the output tree.

